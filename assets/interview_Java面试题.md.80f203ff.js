import{_ as t,c as e,o as l,a as n}from"./app.464941dd.js";const y=JSON.parse('{"title":"Java面试宝典","description":"","frontmatter":{},"headers":[{"level":2,"title":"Java中基本数据类型有哪些","slug":"java中基本数据类型有哪些","link":"#java中基本数据类型有哪些","children":[]},{"level":2,"title":"Integer 和 int的区别","slug":"integer-和-int的区别","link":"#integer-和-int的区别","children":[]},{"level":2,"title":"== 和 equals() 的区别","slug":"和-equals-的区别","link":"#和-equals-的区别","children":[]},{"level":2,"title":"String、StringBuffer 和 StringBuilder 的区别","slug":"string、stringbuffer-和-stringbuilder-的区别","link":"#string、stringbuffer-和-stringbuilder-的区别","children":[]},{"level":2,"title":"final、finally 和 finalize 的区别","slug":"final、finally-和-finalize-的区别","link":"#final、finally-和-finalize-的区别","children":[]},{"level":2,"title":"重写和重载的区别","slug":"重写和重载的区别","link":"#重写和重载的区别","children":[]}],"relativePath":"interview/Java面试题.md","lastUpdated":1679039739000}'),a={name:"interview/Java面试题.md"},i=n(`<h1 id="java面试宝典" tabindex="-1">Java面试宝典 <a class="header-anchor" href="#java面试宝典" aria-hidden="true">#</a></h1><h2 id="java中基本数据类型有哪些" tabindex="-1">Java中基本数据类型有哪些 <a class="header-anchor" href="#java中基本数据类型有哪些" aria-hidden="true">#</a></h2><table><thead><tr><th style="text-align:center;">数据类型</th><th style="text-align:center;">长度</th><th style="text-align:center;">数据范围</th></tr></thead><tbody><tr><td style="text-align:center;">byte</td><td style="text-align:center;">1B</td><td style="text-align:center;">-2^7^~2^7^-1</td></tr><tr><td style="text-align:center;">short</td><td style="text-align:center;">2B</td><td style="text-align:center;">0~2^15^-1</td></tr><tr><td style="text-align:center;">int</td><td style="text-align:center;">4B</td><td style="text-align:center;">-2^31^~2^31^-1</td></tr><tr><td style="text-align:center;">long</td><td style="text-align:center;">8B</td><td style="text-align:center;">-2^63^~2^63^-1</td></tr><tr><td style="text-align:center;">float</td><td style="text-align:center;">4B</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">double</td><td style="text-align:center;">8B</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">char</td><td style="text-align:center;">2B</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">boolean</td><td style="text-align:center;"></td><td style="text-align:center;">true || false</td></tr></tbody></table><h2 id="integer-和-int的区别" tabindex="-1">Integer 和 int的区别 <a class="header-anchor" href="#integer-和-int的区别" aria-hidden="true">#</a></h2><ol><li>int是基本数据类型，其数据范围为 -2^7^ ~2^7^-1 ,作为成员变量的时候，其默认值为0。</li><li>Integer是int的包装类，使int基本数据类型符合Java面向对象的相关特性。</li><li>Integer使用new关键字创建对象，在堆中开辟内存，并对其进行引用；</li><li>深入对比 <ul><li>使用new Integer()创建的两个对象，使用 <strong>==</strong> 进行比较，由于在堆中开辟不同的空间创建对象，因此两个对象不相等</li><li>在int 和 Integer两个对象进行比较的时候，会 <strong>自动拆箱</strong> ，因此只要值相等，两者就想等。</li><li>使用new Integer创建的对象在堆中，使用非new Integer()创建的对象在栈中，因此即使值相等的情况下，使用**==** 比较永不相等。</li><li>使用非new Integer() 创建的Integer对象，由于享元模式的设计理念，如果其值在-128~127之间会在加载的时候进行缓存，直接调用int常量池中对其进行引用</li></ul></li></ol><h2 id="和-equals-的区别" tabindex="-1">== 和 equals() 的区别 <a class="header-anchor" href="#和-equals-的区别" aria-hidden="true">#</a></h2><ol><li><p><strong>==</strong> 比较的是两个对象的地址，而equals()方法的底层也是使用==进行比较的。</p></li><li><p>默认情况下，对象的equals()方法继承于Object类，Object类中也是使用**==** 进行比较的。</p><div class="language-java line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// java.Object.equals()</span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">boolean</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">equals</span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">Object</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(this</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> obj</span><span style="color:#89DDFF;">);</span><span style="color:#A6ACCD;">加</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li><li><p>如果要定制比较就需要重写equals方法。</p></li><li><p>对于包装类，如String,Integer,Charactor,Boolean,Short,Long中都重写了equals()方法。</p></li></ol><h2 id="string、stringbuffer-和-stringbuilder-的区别" tabindex="-1">String、StringBuffer 和 StringBuilder 的区别 <a class="header-anchor" href="#string、stringbuffer-和-stringbuilder-的区别" aria-hidden="true">#</a></h2><ol><li>相同点： <ul><li>String、StringBuffer和StringBuilder的底层都是<strong>char</strong>类型的<strong>数组</strong> 。</li><li>在JDK1.9以后为<strong>byte</strong>类型的<strong>数组</strong> 。</li></ul></li><li>不同点： <ul><li>String中的数组是不可变的，使用了final修饰，可以修改对象名的引用数组对象，不能修改数组中的元素，没有线程安全。</li><li>StringBuffer中的数组是可变的，没有使用final修饰，有线程安全，使用<strong>synchronized</strong> 修饰。</li><li>StringBuilder中的数组是可变的，没有使用final修饰，没有线程安全，性能较高，没有使用<strong>synchronized</strong> 修饰。</li></ul></li></ol><h2 id="final、finally-和-finalize-的区别" tabindex="-1">final、finally 和 finalize 的区别 <a class="header-anchor" href="#final、finally-和-finalize-的区别" aria-hidden="true">#</a></h2><ol><li>final 是java中的<strong>关键字</strong>，表示最终的，最后的；使用final关键字修饰的变量，则该变量在声明和初始化后不能再更改其值；使用final关键字修饰的方法，则表示该方法不能被子类重写；使用final修饰的类，则该类不能被继承。</li><li>finally是<strong>try-catch异常处理结构</strong>中最后无论任何情况下都要执行的代码块，无论是否抓住异常；通常在finally中释放相关占用的资源。</li><li>finalize是java.lang.Object中定义的<strong>方法</strong>，即所有对象都具有该方法；使用该方法会在下次gc的时候回收相关资源。</li></ol><h2 id="重写和重载的区别" tabindex="-1">重写和重载的区别 <a class="header-anchor" href="#重写和重载的区别" aria-hidden="true">#</a></h2><ol><li><p>重写需要以继承关系为前提，重写要求重写的方法的方法名，方法参数列表和返回值类型都要相同；</p></li><li><p>重载发生在同一个类中，只需要方法签名不相同即可</p><p>方法签名=方法名+参数列表</p><p>方法签名不同的三种情况：</p><blockquote><ol><li>方法名相同，参数个数不同</li><li>方法名相同，参数类型不同</li><li>方法名相同，参数顺序不同</li></ol></blockquote></li></ol>`,13),s=[i];function r(o,d,c,g,p,h){return l(),e("div",null,s)}const f=t(a,[["render",r]]);export{y as __pageData,f as default};
